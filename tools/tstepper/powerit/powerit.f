!> @file powerit.f
!! @ingroup powerit
!! @brief Set of subroutines to perform power iterations
!!
!! @author Adam Peplinski
!! @date Mar 7, 2016
!=======================================================================
!> @brief Read parameters for power iterations.
!! @ingroup powerit
!! @param[in]  fid    file unit
!! @note This interface is defined in @ref tstpr_param_in
!! @todo Check iostat value for missing namelist in the file
!! @see @ref readers_writers_page
      subroutine stepper_param_in(fid)
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'            !
      include 'PARALLEL_DEF' 
      include 'PARALLEL'        ! ISIZE, WDSIZE, LSIZE,CSIZE
      include 'POWERITD'

!     argument list
      integer fid               ! file id

!     local variables
      integer ierr, len

!     namelists
      namelist /POWERIT/ PWIL2NORM
!-----------------------------------------------------------------------
!     default values
      PWIL2NORM = 1.0
!     read the file
      ierr=0
      if (NID.eq.0) then
        rewind(fid)
        read(unit=fid,nml=POWERIT,iostat=ierr)
      endif
      call err_chk(ierr,'Error reading POWERIT parameters.$')

!     broadcast data
      len = WDSIZE
      call bcast(PWIL2NORM,len)

      return
      end
!=======================================================================
!> @brief Write parameters for power iterations.
!! @ingroup powerit
!! @param[in]  fid    file unit
!! @note This interface is defined in @ref tstpr_param_out
!! @see @ref readers_writers_page
      subroutine stepper_param_out(fid)
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'      
      include 'POWERITD'         

!     argument list
      integer fid               ! file id

!     local variables
      integer ierr

!     namelists
      namelist /POWERIT/ PWIL2NORM
!-----------------------------------------------------------------------
      ierr=0
      if (NID.eq.0) then
         write(unit=fid,nml=POWERIT,iostat=ierr)
      endif
      call err_chk(ierr,'Error writing POWERIT parameters.$')

      return
      end
!=======================================================================
!> @brief Initialise power iterations.
!! @ingroup powerit
!! @note This interface is defined in @ref tstpr_init
      subroutine stepper_vinit
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'            ! NIO
      include 'MASS_DEF'
      include 'MASS'            ! BM1
      include 'SOLN_DEF'
      include 'SOLN'            ! V[XYZ]P, TP
      include 'CHKPOINTD'       ! IFCHKPTRST
      include 'TIME_STEPPERD'
      include 'POWERITD'        !

!     local variables
      integer ierr
      real lnorm

!     functions
      real dnekclock, cht_glsc2_wt
!-----------------------------------------------------------------------
!     timing
      PWITIME1=dnekclock()

!     check nek5000 parameters

!     for timing
      PWITIMET=0.0

!     initial growth rate
      PWIGRWTH = 0.0

!     place to read checkpoint file
!     as for power iterations standard restart is sufficient I simply
!     use checkpoint call. Notice it does require .restart file, which 
!     supposed to be generated by the code, but there can be exceptions.
      if (IFCHKPTRST) call chkpt_main

!     normalise vector
      lnorm = cht_glsc2_wt(VXP,VYP,VZP,TP,VXP,VYP,VZP,TP,BM1)
      lnorm = sqrt(PWIL2NORM/lnorm)
      call cht_opcmult (VXP,VYP,VZP,TP,lnorm)

!     make sure the velocity and temperature fields are continuous at 
!     element faces and edges
      call tstpr_dssum

!     save intial vector
      call cht_opcopy (PWIVX,PWIVY,PWIVZ,PWIT,VXP,VYP,VZP,TP)

!     open file for saving convergence history
      ierr=0
      if (NID.eq.0) then
!     find free unit
         call IO_file_freeid(PWIFIDCNV, ierr)
!     get file name and open file
         if(ierr.eq.0) then
            open (unit=PWIFIDCNV,file='PWIconv.out',status='new',
     $           action='write',iostat=ierr)
         endif
      endif
      call err_chk(ierr,'ERROR opening PWIconv.out file.$')

!     print info
      if (NIO.eq.0) then
         write(*,*)
         write(*,*) 'POWER ITERATIONS initialised'
         write(*,'(A15,G13.5)') 'L2NORM = ',PWIL2NORM
      endif

!     timing
      PWITIMET=dnekclock()-PWITIME1

      return
      end
!=======================================================================
!> @brief Renormalise vector and check convergence.
!! @ingroup powerit
!! @note This interface is defined in @ref tstpr_solve
!! @remarks This routine uses global scratch space SCRUZ
      subroutine stepper_vsolve
      implicit none

      include 'SIZE_DEF'
      include 'SIZE'            ! NIO
      include 'TSTEP_DEF'
      include 'TSTEP'           ! TIME, LASTEP, NSTEPS
      include 'INPUT_DEF'
      include 'INPUT'           ! IFHEAT
      include 'MASS_DEF'
      include 'MASS'            ! BM1
      include 'SOLN_DEF'
      include 'SOLN'            ! V[XYZ]P, TP
      include 'CHKPOINTD'       ! CHKPTSTEP
      include 'TIME_STEPPERD'   ! TSTTOL, TSTVSTEP
      include 'POWERITD'        !

!     scratch space
      real  TA1 (LPX1*LPY1*LPZ1*LELV), TA2 (LPX1*LPY1*LPZ1*LELV),
     $     TA3 (LPX1*LPY1*LPZ1*LELV), TAT (LPX1*LPY1*LPZ1*LELT)
      COMMON /SCRUZ/ TA1, TA2, TA3, TAT

!     local variables
      integer itmp
      real lnorm, grth_old

!     functions
      real dnekclock, cht_glsc2_wt
!-----------------------------------------------------------------------
!     timing
      PWITIME1=dnekclock()

!     normalise vector
      lnorm = cht_glsc2_wt(VXP,VYP,VZP,TP,VXP,VYP,VZP,TP,BM1)
      lnorm = sqrt(PWIL2NORM/lnorm)
      call cht_opcmult (VXP,VYP,VZP,TP,lnorm)

!     make sure the velocity and temperature fields are continuous at 
!     element faces and edges
      call tstpr_dssum

!     compare current and prevoius growth rate
      grth_old = PWIGRWTH
      PWIGRWTH = 1.0/lnorm
      grth_old = PWIGRWTH - grth_old

!     get L2 norm of the update
      call cht_opsub3 (TA1,TA2,TA3,TAT,PWIVX,PWIVY,PWIVZ,PWIT,
     $     VXP,VYP,VZP,TP)
      lnorm = cht_glsc2_wt(TA1,TA2,TA3,TAT,TA1,TA2,TA3,TAT,BM1)
      lnorm = sqrt(lnorm)

!     stamp the file
      if (NIO.eq.0) then
         write(*,*) 'PWIT: Convergence:'
         write(*,'(A15,G13.5)') '||V-V_old|| ',lnorm
         write(*,'(A15,2G13.5)') 'GrowthRate ',PWIGRWTH, grth_old
      endif
      if (NID.eq.0) write(PWIFIDCNV,'(I13,3E13.5)') TSTVSTEP, lnorm,
     $     PWIGRWTH, grth_old


      itmp = 0
      if (IFHEAT) itmp = 1
!     write down current field
      call outpost2(VXP,VYP,VZP,PRP,TP,itmp,'PWI')

!     write down field difference
      call outpost2(TA1,TA2,TA3,PRP,TAT,itmp,'VDF')

!     check convergence
      if(lnorm.lt.TSTTOL.and.grth_old.lt.TSTTOL) then
         if (NIO.eq.0) write(*,*) 'PWIT: reached stopping criteria'
!     mark the last step
         LASTEP = 1
      else
!     save current vector and restart stepper
         call cht_opcopy (PWIVX,PWIVY,PWIVZ,PWIT,VXP,VYP,VZP,TP)
      endif

!     save checkpoint
      if (LASTEP.eq.1.or.TSTCMAX.eq.TSTVSTEP) then
!     force checkpoint to write the file
         if (NIO.eq.0) write(*,*) 'PWIT: saving restart files'
         NSTEPS = ISTEP
         CHKPTSTEP = NSTEPS-CHKPTNRSF+1
         call chkpt_main

!     close convergence file
         if (NID.eq.0) close(PWIFIDCNV)

!     mark the last step
         LASTEP = 1
      endif

!     timing
      PWITIMET=PWITIMET+dnekclock()-PWITIME1

      if (LASTEP.eq.1) then
!     final log stamp
         if (NIO.eq.0) then
            write(*,*) ''
            write(*,*) 'PWIT: finalize'
            write(*,*) '   Time spent in PWIT  ',PWITIMET
            write(*,*) '   Final convergence:'
            write(*,'(A15,G13.5)') '||V-V_old|| ',lnorm
            write(*,'(A15,2G13.5)') 'GrowthRate ',PWIGRWTH, grth_old
            write(*,*) ''
         endif
      endif

      return
      end
!=======================================================================
